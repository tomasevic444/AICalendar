using AICalendar.Application.DTOs.Event;
using AICalendar.Application.Interfaces;
using AICalendar.Domain;
using AICalendar.Infrastructure.Data;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AICalendar.Infrastructure.Services
{
    public class EventService : IEventService
    {
        private readonly CalendarMongoDbContext _dbContext;
        private readonly IUserService _userService; // To get usernames for participants/owner

        public EventService(CalendarMongoDbContext dbContext, IUserService userService)
        {
            _dbContext = dbContext;
            _userService = userService;
        }

        public async Task<(EventResponseDto? Event, string? ErrorMessage)> CreateEventAsync(CreateEventRequestDto createEventDto, string ownerUserId)
        {
            if (createEventDto.EndTimeUtc <= createEventDto.StartTimeUtc)
            {
                return (null, "EndTimeUtc must be after StartTimeUtc.");
            }

            var ownerUser = await _userService.GetUserByIdAsync(ownerUserId);
            if (ownerUser == null)
            {
                return (null, "Event owner not found."); // Should not happen if ownerUserId comes from valid token
            }

            var newEvent = new EventDocument
            {
                Title = createEventDto.Title,
                Description = createEventDto.Description,
                StartTimeUtc = createEventDto.StartTimeUtc,
                EndTimeUtc = createEventDto.EndTimeUtc,
                OwnerUserId = ownerUserId,
                TimeZoneId = createEventDto.TimeZoneId
                // Id will be generated by MongoDB
            };

            await _dbContext.Events.InsertOneAsync(newEvent);

            // Add the owner as a participant with "Accepted" status
            var ownerParticipant = new EventParticipantDocument
            {
                EventId = newEvent.Id,
                UserId = ownerUserId,
                Status = "Accepted", // Owner is always accepted
                AddedAtUtc = DateTime.UtcNow
            };
            await _dbContext.EventParticipants.InsertOneAsync(ownerParticipant);

            var participantDetailsList = new List<EventParticipantDetailsDto>
            {
                new EventParticipantDetailsDto { UserId = ownerUser.Id, Username = ownerUser.Username, Status = "Accepted" }
            };

            // Add other invited participants
            if (createEventDto.ParticipantUserIds != null)
            {
                foreach (var participantId in createEventDto.ParticipantUserIds.Distinct()) // Distinct to avoid duplicates
                {
                    if (participantId == ownerUserId) continue; // Owner already added

                    var participantUser = await _userService.GetUserByIdAsync(participantId);
                    if (participantUser != null)
                    {
                        var eventParticipant = new EventParticipantDocument
                        {
                            EventId = newEvent.Id,
                            UserId = participantId,
                            Status = "Invited",
                            AddedAtUtc = DateTime.UtcNow
                        };
                        await _dbContext.EventParticipants.InsertOneAsync(eventParticipant);
                        participantDetailsList.Add(new EventParticipantDetailsDto { UserId = participantUser.Id, Username = participantUser.Username, Status = "Invited" });
                    }
                    // Else: Log warning that a participant ID was not found? Or return an error?
                    // For now, we'll just skip non-existent invited users.
                }
            }

            var eventResponse = new EventResponseDto
            {
                Id = newEvent.Id,
                Title = newEvent.Title,
                Description = newEvent.Description,
                StartTimeUtc = newEvent.StartTimeUtc,
                EndTimeUtc = newEvent.EndTimeUtc,
                OwnerUserId = newEvent.OwnerUserId,
                OwnerUsername = ownerUser.Username, // Get owner's username
                TimeZoneId = newEvent.TimeZoneId,
                Participants = participantDetailsList
            };

            return (eventResponse, null);
        }

        // We will implement GetEventByIdAsync, GetEventsForUserByPeriodAsync,
        // UpdateEventAsync, and DeleteEventAsync in subsequent focused steps.
        // For now, let's add stubs so the class compiles:

        public async Task<EventResponseDto?> GetEventByIdAsync(string eventId, string requestingUserId)
        {
            // TODO: Implement actual logic
            // 1. Fetch EventDocument
            // 2. Fetch its EventParticipantDocuments
            // 3. Check if requestingUserId is owner or a participant (Authorization)
            // 4. Populate Usernames for owner and participants
            // 5. Map to EventResponseDto
            await Task.CompletedTask; // Placeholder
            return null; // Placeholder
        }

        public async Task<IEnumerable<EventResponseDto>> GetEventsForUserByPeriodAsync(string userId, DateTime startPeriodUtc, DateTime endPeriodUtc)
        {
            // TODO: Implement actual logic
            // 1. Find all EventParticipantDocuments where UserId = userId
            // 2. For those events, fetch the EventDocument if it falls within the period
            //    (Event.StartTimeUtc < endPeriodUtc && Event.EndTimeUtc > startPeriodUtc)
            // 3. For each valid event, fetch all its participants and owner details
            // 4. Map to List<EventResponseDto>
            await Task.CompletedTask; // Placeholder
            return new List<EventResponseDto>(); // Placeholder
        }

        public async Task<(bool Success, string? ErrorMessage, EventResponseDto? UpdatedEvent)> UpdateEventAsync(string eventId, UpdateEventRequestDto updateEventDto, string ownerUserId)
        {
            // TODO: Implement actual logic
            // 1. Fetch EventDocument
            // 2. Check if ownerUserId matches Event.OwnerUserId (Authorization)
            // 3. Validate times (EndTime > StartTime if both provided)
            // 4. Apply updates from DTO to EventDocument
            // 5. Save changes
            // 6. Fetch updated participant list and map to EventResponseDto (or return simpler success)
            await Task.CompletedTask; // Placeholder
            return (false, "Not implemented", null); // Placeholder
        }

        public async Task<(bool Success, string? ErrorMessage)> DeleteEventAsync(string eventId, string ownerUserId)
        {
            // TODO: Implement actual logic
            // 1. Fetch EventDocument
            // 2. Check if ownerUserId matches Event.OwnerUserId (Authorization)
            // 3. Delete EventDocument
            // 4. Delete all associated EventParticipantDocuments for this eventId
            await Task.CompletedTask; // Placeholder
            return (false, "Not implemented"); // Placeholder
        }
    }
}