using AICalendar.Application.DTOs;
using AICalendar.Application.DTOs.User;
using AICalendar.Application.Interfaces;
using AICalendar.Domain;
using AICalendar.Infrastructure.Data;
using MongoDB.Driver;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using BCryptNet = BCrypt.Net.BCrypt; // Alias for clarity

namespace AICalendar.Infrastructure.Services
{
    public class UserService : IUserService
    {
        private readonly IMongoCollection<UserDocument> _usersCollection;

        public UserService(CalendarMongoDbContext dbContext)
        {
            _usersCollection = dbContext.Users;
        }

        public async Task<(UserResponseDto? User, string? ErrorMessage)> CreateUserAsync(CreateUserRequestDto createUserDto)
        {
            var existingUser = await _usersCollection.Find(u => u.Username == createUserDto.Username).FirstOrDefaultAsync();
            if (existingUser != null)
            {
                return (null, "Username already exists.");
            }

            var newUser = new UserDocument
            {
                Username = createUserDto.Username,
                PasswordHash = BCryptNet.HashPassword(createUserDto.Password)
                // Id will be generated by MongoDB
            };

            await _usersCollection.InsertOneAsync(newUser);


            var userResponse = new UserResponseDto
            {
                Id = newUser.Id, // Requires Id to be set after insert
                Username = newUser.Username
            };
            return (userResponse, null);
        }

        public async Task<UserDocument?> GetUserByIdAsync(string userId)
        {
            return await _usersCollection.Find(u => u.Id == userId).FirstOrDefaultAsync();
        }

        public async Task<UserResponseDto?> GetUserResponseByIdAsync(string userId)
        {
            var user = await GetUserByIdAsync(userId);
            if (user == null) return null;
            return new UserResponseDto { Id = user.Id, Username = user.Username };
        }


        public async Task<UserDocument?> GetUserByUsernameAsync(string username)
        {
            return await _usersCollection.Find(u => u.Username == username).FirstOrDefaultAsync();
        }

        public async Task<IEnumerable<UserResponseDto>> GetAllUsersAsync()
        {
            var users = await _usersCollection.Find(_ => true).ToListAsync();
            return users.Select(u => new UserResponseDto { Id = u.Id, Username = u.Username });
        }

        public async Task<(bool Success, string? ErrorMessage)> DeleteUserAsync(string userIdToDelete, string currentUserId)
        {
            if (userIdToDelete == currentUserId)
            {
                return (false, "Users cannot delete themselves through this operation.");
            }


            var result = await _usersCollection.DeleteOneAsync(u => u.Id == userIdToDelete);
            if (result.IsAcknowledged && result.DeletedCount > 0)
            {
                return (true, null);
            }
            return (false, "User not found or delete failed.");
        }
    }
}

